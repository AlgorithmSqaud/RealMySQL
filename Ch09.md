# 9장 옵티마이저와 힌트

여행을 할 때 계획을 세워서 비용과 이동거리를 최소화하여 경로를 결정하듯이, MySQL에서도 쿼리를 최적으로 실행하기 위해서 통계 정보를 참조하여 실행 계획을 수립하는 작업이 필요하다. 많은 DBMS에서 옵티마이저가 그 기능을 담당한다.



## 9.1 개요

옵티마이저는 어렵다. 옵티마이저가 만드는 실행 계획 또한 어렵다. 하지만 이해해야 최적화된 쿼리 작성이 가능하다.

References: 

- https://www.datadoghq.com
- https://dev.mysql.com/doc/refman/8.0/en/controlling-optimizer.html
- https://dev.mysql.com/doc/internals/en/optimizer-definitions.html



### 9.1.1 쿼리 실행 절차

#### MySQL 서버에서 쿼리가 실행되는 과정

1. SQL Parsing

요청된 SQL 문장을 MySQL 서버가 이해할 수 있는 수준으로 분리(Parse Tree)

- MySQL 서버의 SQL Parser가 SQL 문법을 검증한다.
- SQL Parse Tree가 생성된다. (MySQL 서버는 이를 기준으로 쿼리를 실행)

2. 최적화 및 계획수립

SQL의 파싱 정보(Parse Tree)를 확인하면서 테이블, 인덱스를 읽는 순서를 선택

- 불필요한 조건 제거 및 연산의 단순화
- 여러 테이블의 조인에서 테이블 읽는 순서 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공할지 결정

3. 수립된 계획대로 레코드를 읽음

결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리



### 9.1.2 옵티마이저의 종류

옵티마이저는 DB 서버에서 두뇌 역할

#### 비용 기반 최적화(Cost-Based Optimizer, CBO)

- 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고
- 각 단위 작업의 비용(부하) + 대상 테이블의 예측된 통계 정보 &rarr; 실행 계획별 비용 산출
- 산출된 실행 방법별 비용이 최소가 되는 쿼리 선택

#### 규칙 기반 최적화(Rule-Based Optimizer, RBO)

- 대상 테이블 레코드 건수나 선택도 등 통계 정보 고려 x
- 옵티마이저에 내장도니 우선순위에 따라 고정된 실행 계획 수립
- 사용자 데이터 분포도는 매우 다양하므로 거의 사용 x

---



## 9.2 기본 데이터 처리

RDBMS는 데이터를 정렬하거나 그루핑하는 기본 데이터 가공 기능을 가진다. 하지만 그 과정은 모두 다르다.



### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

#### 풀 테이블 스캔

인덱스 없이 전체를 읽는다.

##### 풀 테이블 스캔의 조건

- 테이블 레코드 건수가 너무 작은 경우
- WHERE 절이나 ON 절에 인덱스를 이용할 조건이 없는 경우
- 두 조건을 만족해도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

##### 디스크 읽기 단위

- MyISAM: 페이지를 하나씩 읽어옴
- InnoDB: 특정 테이블의 연속된 데이터 페이지가 읽히면 **Read Ahead**가 수행

##### Read Ahead

앞으로 읽을 데이터를 예측해서 미리 가져오는 작업 (지역성을 고려)
`innodb_read_ahead_threashold` 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 Read Ahead를 시작할지 임계값을 설정할 수 있다.

`SELECT COUNT(*) FROM employees;`를 실행하면 풀 인덱스 스캔
`SELECT * FROM employees;`를 실행하면 레코드에만 있는 컬럼이 필요하므로 플 테이블 스캔

References:

- https://dev.mysql.com/doc/refman/8.0/en/innodb-disk-io.html



> **Pyro**:
> 가우시안 분포를 이용해서 지역성을 고려하는데 근처에 있는게 얼마나 히트될것인지 계산.
> read ahead가 커질수록 좋아지는게 로그함수를 따르는데 일정이상 커지면 별차이가 없어진다.



### 9.2.2 병렬 처리

MySQL 8.0부터 **하나의 쿼리**를 여러 스레드가 동시에 처리하는게 가능해짐

`innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드로 처리할지 결정.



### 9.2.3 ORDER BY 처리(Using filesort)

#### 정렬을 처리하는 방법

|               | 장점                                                         | 단점                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 인덱스 이용   | INSERT, UPDATE, DELETE 시 이미 인덱스가 정렬되어 매우 빠름   | INSERT, UPDATE, DELETE 작업 시 인덱스 추가/삭제 작업 필요, 디스크 공간, 메모리 많이 필요 |
| Filesort 이용 | 인덱스 부가 작업과 공간이 필요 x, 정렬해야할 레코드 적으면 메모리에서 Filesort되어 빠름 | 정렬 작업이 쿼리 실행 시 처리되어 레코드가 많아지면 응답 느림 |

Pyro:
CUD PK 주소가 필요하다. 그래서 인덱스가 걸려있으면 빠르다.
PK인덱스 기준이 없다면 다른 기준으로 풀 스캔해서 찾아서 지우든지 해야해서 느릴 수 있다.

#### 정렬에 인덱스를 이용하기 어려운 경우

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 or DISTINCT 처리 결과를 정렬해야하는 경우
- UNION 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우



#### 9.2.3.1 소트 버퍼

- MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용 -> 소트 버퍼
- 정렬이 필요한 경우에만 할당
- 버퍼의 크기는 정렬해야 할 레코드 크기에 따라 가변적으로 증가
- 최대 가용 소트 버퍼 크기는 `sort_buffer_size`로 설정 가능
- 소트 버퍼용 메모리 공간은 쿼리 실행 완료 즉시 시스템으로 반납

##### 정렬할 레코드 건수가 소트 버퍼 공간보다 큰 경우

메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록
그리고 다음 레코드를 가져와서 다시 정렬, 반복적으로 디스크에 임시 저장
각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬 수행

##### 소트 버퍼 크기에 따른 성능

`sort_buffer_size`가 크다고 무조건 성능이 좋은게 아니다.
소트 버퍼 크기가 크면 디스크 I/O를 줄일 수 있지만, 서버의 메모리가 부족해질 수 있다.
따라서 적절한 임계값(56KB ~ 1MB가 적절)을 지정하는게 좋다.

Pyro:
정렬하기 위해 데이터를 메모리에 올려놓는데, 정렬 대상 데이터의 크기가 다를 수 있다.
auto_incremented는 고정값이지만, varchar라면 메모리에 올릴 수 있는 양이 다를 수 있어서 들쑥날쑥 할수도 있겠다.



#### 9.2.3.2 정렬 알고리즘

레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 or 정렬 기준 컬럼만 담을지에 따라 2가지 정렬 모드로 나뉜다.



##### 9.2.3.2.1 싱글 패스 정렬 방식

소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 정렬 방식

```sql
SELECT emp_no, first_name, last_name
FROM employees
ORDER BY first_name;
```

emp_no, first_name, last_name 컬럼 조회 &rarr; 소트 버퍼에 담고 정렬 &rarr; 정렬 버퍼의 내용을 클라이언트로 반환 (멀티 머지가 필요하면 중간과정에서 수행)



##### 9.2.3.2.2 투 패스 정렬 방식

정렬 대상 컬럼과 PK값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 PK로 테이블을 읽어서 SELECT할 컬럼을 가져오는 정렬 방식

emp_no, first_name 컬럼만 조회 &rarr; 소트 버퍼에 담고 정렬 &rarr; 정렬 버퍼의 내용을 기반으로 employees 테이블을 한 번 더 읽어서 last_name을 가져오고 클라이언트로 반환 (멀티 머지가 필요하면 중간과정에서 수행)

**투 패스 정렬 방식을 사용하는 경우**

- 레코드의 크기가 `max_length_for_sort_data`값 보다 큰 경우
- BLOB나 TEXT 타입의 컬럼이 SELECT 대상에 포함되는 경우

> `SELECT * FROM employees`가 아니라 `SELECT emp_no, first_name, last_name FROM employees`를 사용해야 하는 이유가 바로 이것이다. 정렬이 필요한 SELECT는 불필요한 컬럼을 SELECT할 경우 투 패스를 사용할 가능성이 커진다. 그리고 임시 테이블이 필요한 쿼리에서도 영향을 미친다.



Woody:
엔티티를 들고올때 와 `SELECT *` 와 동일한게 아닌가?
하나의 테이블에 대해서 엔티티가 여러개 사용될수도 있을것 같다.

Pyro:
하나의 테이블에 엔티티를 따로 만들자.
@Column, @Entity(name = "")



#### 9.2.3.3 정렬 처리 방법

| 정렬 처리 방법                                  | 실행 계획의 Extra 컬럼 내용                    |
| ----------------------------------------------- | ---------------------------------------------- |
| 인덱스를 사용한 정렬                            | 별도 표기 없음                                 |
| 조인에서 드라이빙 테이블만 정렬                 | "Using filesort" 메시지가 표시                 |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "Using temporary; Using filesort"메시지가 표시 |

**옵티마이저의 정렬 처리**

인덱스 이용 여부 검토  
&rarr; 이용 가능하다면 별도의 "Filesort"없이 인덱스를 순서대로 읽어서 결과 반환
&rarr; 이용 불가능하다면 별도의 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)

이때 정렬 대상 레코드를 최소화하기 위해 2가지 방법 중 선택

- 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

일반적으로 조인이 수행되면서 레코드 건수와 레코드 크기는 매우 커지므로 가능한한 드라이빙 테이블만 정렬한 다음 조인을 수행하는게 효율적이다.



##### 9.2.3.3.1 인덱스를 이용한 정렬

인덱스를 이용한 정렬의 조건

- ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블에 속한다.
- ORDER BY의 순서대로 생성된 인덱스가 있어야한다.
- WHERE절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
- 여러 테이블이 조인되는 경우에는 Nested-loop 조인에서만 가능하다.

```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.emp_no; -- 옵티마이저가 알아서 하니까 일부러 지우진 말자.
```

employees 테이블의 PK를 읽고, salaries 테이블을 조인했기 때문에 employees의 PK인 emp_no로 정렬이 유지된다.

References:

- [Nested Loop](https://dev.mysql.com/doc/refman/8.0/en/nested-loop-joins.html#:~:text=Loop%20Join%20Algorithm-,Nested%2DLoop%20Join%20Algorithm,remain%20tables%20to%20be%20joined.)
- https://needjarvis.tistory.com/162



##### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬

조인이 수행되면 레코드가 커지므로 조인을 실행하기 전에 테이블을 정렬하고 다음 조인을 실행하는 것이 차선책이다.
이 방법으로 정렬하려면 첫 번째 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절을 작성해야 한다.

```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no -- emp_no 컬럼에 인덱스가 있다.
AND e.emp_no BETWEEN 100002 AND 100010 -- employees 테이블의 PK를 이용해 작업량을 줄일 수 있다.
ORDER BY e.last_name;
```

두 조건으로 옵티마이저는 employees를 드라이빙 테이블로 선택한다.

- WHERE 절의 검색 조건은 employees 테이블의 PK를 이용해 작업량을 줄일 수 있다.
- 드리븐 테이블(salaries)의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다.

검색은 인덱스 레인지 스캔으로 처리할 수 있지만 ORDER BY에 명시된 컬럼은 employees 테이블의 PK와 연관이 없으므로 인덱스를 이용한 정렬은 불가능하다. 그런데 ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블에 포함된 컬럼이다. 옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고, 그 결과와 salaries 테이블을 조인한 것이다.

1. 인덱스를 이용해 조건을 만족하는 레코드 검색
2. 검색 결과를 last_name 컬럼으로 정렬 수행(Filesort)
3. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해 최종 결과를 가져옴



##### 9.2.3.3.3 임시 테이블을 이용한 정렬

쿼리가 여러 개가 아닌 하나의 테이블로부터 SELECT해서 정렬하는겨우라면 임시 테이블이 필요하지 않을 수 있다. 하지만 2개 이상을 조인해서 정렬해야한다면 임시테이블이 필요할 수 있다.

앞의 경우 외에는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.
이 방법은 정렬할 레코드가 가장 많아서 가장 느리다.

```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary; -- 정렬 기준 컬럼이 드리븐 테이블에 있다.
```

정렬이 수행되기 전에 salaries 테이블을 읽어야 하므로, 이 쿼리는 조인된 데이터를 가지고 정렬할 수 밖에 없다.



> **August**:
> 드라이빙 테이블이 무엇인가?
> FROM 절 앞에있는 테이블?
> ORDER BY 기준이 되는 컬럼을 가지고 있는 테이블?
> [드라이빙 테이블 선정 기준](https://itwiki.kr/w/%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B9%99_%ED%85%8C%EC%9D%B4%EB%B8%94)
> 조인 시 먼저 엑세스 되어 읽어지는 테이블, 하지만 어떻게 선택되는지는 좀 더 조사해보자..
>
> **Pyro**:
> 드라이빙 테이블 선택에 따라 성능의 차이가 있느냐? -> 있다.
>
> **Woody**:
> DB에서 소팅 vs App에서 소팅
> 인덱스를 탈 수 있는 경우는 DB에서 소팅
> 인덱스를 탈 수 없는 경우는 복잡하고 조인도 많이 들어가고 쿼리가 너무 길어지면 앱에서 해도 나쁘지 않을것 같다.
> 그 기준은 서버 스펙에 맞춰서 메모리 용량을 따져봐야할듯
>
> **Pyro**:
> 앱에서 정렬은 최대한 피하는 것 같다.
> 엔드포인트 커넥션 부하에 집중하고 정렬 등 앱의 핵심로직에 집중한다.
> 심지어 FE에서 정렬을 담당하기도 한다.
> 조인을 앱에서 하는 경우도 많다. 몽고 DB로 넘어가는 현상이 자꾸 발생
>
> **Woody**:
> 앱에서 조인한다는게 각자 쿼리 날려서 가져온다음 앱에서 합친다? -> 네
> n+1이 발생하지 않는가? -> 잘 하면..
>
> **Pyro**:
> 드리븐 테이블에 FK가 있을텐데 그걸로 다시 쿼리 날리기
> 조인 조건과 드리븐테이블 조건이 있는데, 드리븐 테이블에서 where 조건 기준이 있다.
> 드리븐 테이블에 100개를 가져온 다음 in절로 두번째 테이블을 가져온다.
> 사실상 순수한 조인은 앱 상에서는 불가능할지도..
>
> **Dong**:
> 모든 소팅을 서버에서 시키는데 이유는
> DB확장이 어렵다. 샤딩이 어렵다. 이미 돌고있는 DB서버도 최고스펙이지만 select * 로 뻗는다.
> 서버에서 하면 확장은 쉽다. VM올리고 하면 확장이 용이 but DB는 확장이 어렵다.
> VM서버들도 VM 자체 성능이 올라가면 스펙이 정렬, 조인 성능에 그대로 반영된다.
> AWS는 물리 머신대비 90% 성능인데, IDC사용시 70% 성능으로 되기도 해서
> 앱에서 다 담당하고 있다.



##### 9.2.3.3.4 정렬 처리 방법의 성능 비교

웹 서비스용 쿼리에서는 ORDER BY와 함께 LIMIT가 사용된다. (페이지네이션, 페이징)
ORDER BY나 GROUP BY는 WHERE 조건을 만족하는 레코드를 LIMIT 만큼만 가져와서는 처리할 수 없다.
우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 해야만 LIMIT로 제한할 수 있다.
WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 ORDER BY, GROUP BY로 느려질 수 있다.

**스트리밍 방식**

서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
클라이언트는 쿼리를 요청하고 바로 첫 번째 레코드를 전달받는다.
쿼리가 조회하는 레코드 양과 상관없이 빠른 응답시간을 보장해준다.
LIMIT처럼 결과 건수를 제한하는 조건은 쿼리 실행시간을 줄여준다.

**버퍼링 방식**

ORDER BY나 GROUP BY 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다.
MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지않고 기다려야 하기 때문에 응답 속도가 느려진다.
LIMIT처럼 결과 건수를 제한하는 조건이 있어도 성능에는 별로 도움이 되지 않는다.

> MySQL이 스트리밍으로 보내줘봤자 JDBC가 버퍼링으로 처리해서 결국엔 클라이언트는 느린 응답을 받는다. 하지만 SQL 클라이언트 도구는 스트리밍 방식으로 보여주기 떄문에 비교적 빠르다. DataGrip이나 WorkBench가 월등히 빠르다.

```sql
SELECT *
FROM tb_test1 t1, tb_test t2
WHERE t1.col1 = t2.col1
ORDER BY t1.col2
LIMIT 10;
```

tb_test1: 100 records
tb_test2: 1000 records

어느 테이블이 먼저 드라이빙되어 조인되는지도 중요하지만, 어떤 정렬 방식으로 처리되는지가 더 중요
최소한 드라이빙 테이블만이라도 정렬해도 되는 수준으로 튜닝

> 인덱스를 사용하지 못하고 별도로 Filesort 작업을 거쳐야 하는 쿼리에서 LIMIT가 도움이 될수도 있다. 예를 들어, `LIMIT 10`인데 10개가 나왔다면 정렬을 멈추고 반환할수도 있다. 하지만 정렬 알고리즘에 따라 별 차이가 없다.



#### 9.2.3.4 정렬 관련 상태 변수

| 상태변수          | 설명                                                        |
| ----------------- | ----------------------------------------------------------- |
| Sort_merge_passes | 멀티 머지 처리 횟수                                         |
| Sort_range        | 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수 |
| Sort_scan         | 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수     |
| Sort_rows         | 지금까지 정렬한 전체 레코드 건수                            |



### 9.2.4 GROUP BY 처리

GROUP BY도 스트리밍 처리를 할 수 없게 하는 처리
HAVING은 GROUP BY 결과에 대해 필터링
GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING 절을 튜닝하려고 애쓸 필요 x



#### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

조인의 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 GROUP BY 컬럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.



#### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY

루스(Loose) 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
옵티마이저가 루스 인덱스 스캔을 사용할 때는 실행 계획의 Extra 컬럼에 "Using index for group-by" 표시

```sql
EXPLAIN
    SELECT emp_no
    FROM salaries
    WHERE from_date = '1985-03-01'
    GROUP BY emp_no;
```

> **August**: 쿼리 실제로 이것저것 해보면서 추가하면 이해가 될듯



#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY

GROUP BY의 기준 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.

```sql
EXPLAIN
    SELECT e.last_name, AVG(s.salary)
    FROM employees e, salaries s
    WHERE s.emp_no = e.emp_no
    GROUP BY e.last_name;
    -- ORDER BY e.last_name;
```

"Using filesort"가 아니라 "Using temporary"만 표시
GROUP BY에는 있지만 ORDER BY가 없는 쿼리에 대해서 기본적으로 그루핑 컬럼(last_name)으로 정렬된 결과를 반환했지만, 8.0 부터는 묵시적인 정렬 x



### 9.2.5 DISTINCT 처리

DISTINCT는 집계함수의 사용여부에 따라 처리가 달라진다.



#### 9.2.5.1 SELECT DISTINCT ...

GROUP BY와 동일한 방식으로 처리
8.0 부터는 두 쿼리가 동일

```sql
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROM salaries GROUP BY emp_no;
```

DISTINCT는 특정 컬럼만 유니크하게 조회하는 것이 아니라, 조합 전체(row)가 유니크한 레코드를 가져온다.
SELECT절에 사용된 DISTINCT 키워드는 조회되는 모든 컬럼에 영향을 미친다.

```sql
SELECT DISTINCT first_name, last_name FROM employees;
SELECT DISTINCT(first_name), last_name FROM employees; -- 결과는 동일
```

> **August:**
> GROUP BY 하면 최상단의 레코드로 채워지는가? -> 아마도
> <u>QueryDSL에서 서브쿼리에서 SELECT하는데 LIMIT 1 이 무시된다.</u>
> SELECT (SELECT ~ LIMIT 1)



#### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT

집합 함수 내에서 DISTINCT는 그 집합 함수의 인자로 전달된 컬럼값이 유니크한 것들을 가져온다.

```sql
EXPLAIN
    SELECT COUNT(DISTINCT s.salary)
    FROM employees e, salaries s
    WHERE e.emp_no = s.emp_no
    AND e.emp_no BETWEEN 100001 AND 100100;
```

내부적으로 임시 테이블을 사용한다.

```sql
    SELECT COUNT(DISTINCT s.salary),
           COUNT(DISTINCT e.last_name)
    FROM employees e, salaries s
    WHERE e.emp_no = s.emp_no
    AND e.emp_no BETWEEN 100001 AND 100100;
```

내부적으로 임시 테이블 2개를 사용한다.

```sql
SELECT COUNT(DISTINCT emp_no) FROM employees;
SELECT COUNT(DISTINCT emp_no) FROM dept_emp GROUP BY dept_no;
```

인덱스된 컬럼에 DISTINCT 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔, 임시 테이블 없이 최적화 가능



### 9.2.6 내부 임시 테이블 활용

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블을 사용한다.

- "CREATE TEMPORARY TABLE" 명령으로 만든 임시 테이블과 다르다.
- 다른 세션이나 다른 쿼리에서 볼 수 x, 사용 x
- 쿼리의 처리가 완료되면 자동 삭제



#### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블

MySQL 8.0 부터는 `internal_tmp_mem_storage_engine` 시스템 변수로 메모리용 임시 테이블을 MEMORY와 TempTable(기본값) 중에 선택할 수 있게 한다.



#### 9.2.6.2 임시 테이블이 필요한 쿼리

- ORDER BY와 GROUP BY에 명시된 컬럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 or DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리 (select_type 컬럼이 UNION RESULT인 경우)
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리



#### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우

- UNION이나 UNION ALL에서 SELECT되는 컬럼 중에서 길이가 512Bytes 이상인 크기의 컬럼이 있는 경우
- GROUP BY나 DISTINCT 컬럼에서 512Bytes 이상인 크기의 컬럼이 있는 경우
- 메모리 임시 테이블의 크기가 tmp_table_size 또는 max_heap_table_size 보다 크거나 temptable_max_ram 보다 큰 경우



#### 9.2.6.4 임시 테이블 관련 상태 변수

| 상태변수                | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| Created_tmp_tables      | 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태값 |
| Created_tmp_disk_tables | 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태값 |

---



## 9.3 고급 최적화

### 9.3.1 옵티마이저 스위치 옵션

### 9.3.2 조인 최적화 알고리즘

---

## 9.4 쿼리 힌트

### 9.4.1 인덱스 힌트

### 9.4.2 옵티마이저 힌트
