  

# 10 실행 계획

  

## 10.1 통계 정보


### 10.1.1 테이블 및 인덱스 통계 정보
#### MySQKL 서버의 통계 정보
- MySQL 5.6 이전
    - 메모리에만 관리
    - SHOW INDEX 명령으로만 테이블의 인덱스 칼럼 분포도를 확인할 수 있었음
- MySQL 5.6 부터
    - InnoDB 스토리지 엔진 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있음
    - mysql 데이터베이스의 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리 가능
    - 서버 재시작해도 기존 통계 정보 유지할 수 있게 되었다

```sql
STATS_PERSISTENT -- 해당 옵션으로 영구적으로 통계 정보를 보관할지 결정
```
### 10.1.2 히스토그램

### 10.1.3 코스트 모델(Cost Model)

 

## 10.2 실행 계획 확인


### 10.2.1 실행 계획 출력 포맷

### 10.2.2 쿼리의 실행 시간 확인

  

## 10.3 실행 계획 분석


### 10.3.1 id 칼럼

### 10.3.2 select_type 칼럼
#### Simple

#### Primary

#### Union

#### Dependent Union

#### Union Result

#### Subquery

#### Dependent Derived
- [lateral join 설명 링크](https://stackoverflow.com/a/28551339)

#### Uncacheable Subquery
- 캐시 사용하지 못하게 하는 요소들 3가지

#### Uncacheable Union

#### Materialized
- MySQL 5.7 버전 부터 지원
- FROM절 혹은 IN(subquery) 형태의 쿼리에 대해서, 서브쿼리 내용을 임시 테이블로 구체화한 뒤 outer 테이블과 조인하는 형태로 최적화
- Derived 와 동일하게 작동, 서브쿼리의 위치가 다른 것일 뿐임

### 10.3.3 table 칼럼
- MySQL 서버의 실행 계획은 테이블 기준
- <> 표시는 임시 테이블을 의미, 안의 숫자는 단위 SELECT 쿼리 id 값을 지칭

### 10.3.4 partitions 칼럼
- MySQL 8.0 버전부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 한 번에 확인 가능
- 파티션 프루닝 : 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하도록, 테이블을 골라내는 과정
- 옵티마이저에서는 쿼리의 조건들을 확인하고, 필요한 파티션만 접근하는 파티션 프루닝으로 쿼리 최적화 시도
   - (+) 대부분 RDB에서 지원하는 파티션은 물리적으로 별도의 공간을 가진다 (그러니, 실행 계획 상으로는 type ALL로 뜰 수 있으니 놀라지 말 것. 우리들이 생각하는 풀스캔 타는거 아님)

### 10.3.5 type 칼럼
- type 컬럼 == 조인 타입... 이라고 되어있지만 '각 테이블의 접근 방법'이라고 생각해도 좋음

#### system
- 레코드가 1건 혹은 아예 존재하지 않는 테이블 참조
- MyISAM 혹은 MEMORY 테이블에서만 사용

#### const
- 프라이머리 키 혹은 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있음
- 반드시 1건을 반환하는 쿼리만을 처리
- 유니크 인덱스 스캔이라고도 함
- 일부 칼럼만 조건을 사용할 때는 X -> const가 아닌 ref
#### eq_ref
- 여러 테이블이 조인되는 쿼리 실행 계획에서만 표시
- 두 번째 조인되는 테이블의 type 컬럼부터 eq_ref
#### ref
- 조인의 순서와 관계 없이 사용
- 제약 조건도 X
- 반드시 1건이라는 보장이 없음
- 동등 조건으로만 비교 -> 빠름

#### fulltext
- MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방식

#### ref_or_null
- ref 접근 방법 + null 비교 추가

#### unique_subquery
- Where 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방식

#### index_subquery
- IN(subquery) 서브 쿼리 결과에서 중복된 값이 발생했을 때, 인덱스로 중복된 값을 제거할 수 있음

#### range

### 10.3.6 possible_keys 칼럼
- 

### 10.3.7 key 칼럼

### 10.3.8 key_len 칼럼

### 10.3.9 ref 칼럼

### 10.3.10 rows 칼럼

### 10.3.11 filtered 칼럼
